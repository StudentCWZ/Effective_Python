# -*- coding: utf-8 -*-
# @Author: StudentCWZ
# @Date:   2022-04-12 13:52:33
# @Last Modified by:   StudentCWZ
# @Last Modified time: 2022-04-12 13:52:33


# 第九条：用生成器表达式来改写数据量较大的列表推导


"""
    1. 列表推导的缺点是：在推导的过程中，对于输入序列中的每个值来说，可能都要创建仅含一项元素的全新列表。
    2. 当输入的数据比较少时，不会出现问题，但如果输入的数据非常多，那么可能会消耗大量内存，并导致程序崩溃。
    3. 例如，要读取一份文件并返回每行的字符数。若采列表推导来做，则需把文件每一行的长度都保存在内存中。如果这个文件特别大，或是通过无休止的
       network socket(网络套接字) 来读取，那么这种列表推导就会出现问题。
    4. 为了解决此问题，Python 提供了生成器表达式，它是对列表推导和生成器的一种泛化。
    5. 生成器表达式在运行的时候，并不会把整个输出序列都呈现出来，而是会估值为迭代器，这个迭代器每次可以根据生成器表达式产生一项数据。
    6. 把实现列表推导所用的那种写法放在一对圆括号中，就构成了生成器表达式。
    7. 二者的区别在于，对生成器表达式求值的时候，它会立刻返回迭代器，而不会深入处理文件中的内容。
    8. 使用返回的迭代器为参数，逐次调用内置的 next 函数，即可使其按照生成表达式来生成新的值，而不用担心内存用量激增。
    9. 使用生成器表达式还有一个好处，就是可以相互结合。外围的迭代器每次前进时，都会推动内部那个迭代器，这就产生了看所效应，使得执行循环、
       评估条件表达式、对接输入和输出等逻辑豆组合在了一起。
    10. 总结：
        - 当输入的数据量较大时，列表推导可能会因为占用太多内存而出问题。
        - 由生成器表达式所返回的迭代器，可以逐次产生输出值，从而避免了内存用量问题。
        - 把某个生成器表达式所返回的迭代器，放在另一个生成器表达式的 for 子表达式中，即可将二者组合起来。
        - 串在一起的生成器表达式执行速度很快。
"""


# Example one
value = [len(x) for x in open('./my_file.txt')]
print(value)
print('--------------------------------------')

# Example two
it = (len(x) for x in open('./my_file.txt'))
print(it)
print(next(it))
print(next(it))
print('--------------------------------------')

# Example three
roots = ((x, x**0.5) for x in it)
print(next(roots))




